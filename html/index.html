<!doctype html>
<html lang="en">
<head>
  <title>Factini</title>
  <meta charset="utf-8">
<!--  <meta name="viewport" content="width=device-width, user-scalable=no">-->
</head>
<body>

<script src="config.md.js" charset="UTF-8"></script>
<script src="config.assets.md.js" charset="UTF-8"></script>
<script src="config.belts.md.js" charset="UTF-8"></script>
<script src="config.machines.md.js" charset="UTF-8"></script>
<script src="config.supplydemandock.md.js" charset="UTF-8"></script>

<script src="quests/dev.quests.md.js" charset="UTF-8"></script>
<script src="quests/dev.parts.md.js" charset="UTF-8"></script>

<script src="quests/bucket_quest.md.js" charset="UTF-8"></script>

<script src="quests/maze.story.md.js" charset="UTF-8"></script>

<script src="map.md.js" charset="UTF-8"></script>
<script src="options.md.js" charset="UTF-8"></script>
<script src="examples.md.js" charset="UTF-8"></script>
<script>
  var queuedAction = '';
  var queuedPaste = '';

  function getGameConfig() { return $game_config.value; /*GAME_CONFIG*/ }
  function getGameMap() { return $game_map.value /*GAME_MAP*/; }
  function getGameOptions() {
    console.log('[js] getGameOptions()');
    //console.log('[js] getGameOptions(): going to send it this:\n', $game_options.value);
    return $game_options.value /*GAME_OPTIONS*/;
  }
  function setGameOptions(optionStr, onLoad) {
    // Note: onLoad is first time Rust passes the options to the UI and again when map is loaded. It is NOT the initial options.md.js fetch, which happens first.
    console.log('[js] setGameOptions(', GAME_OPTIONS === optionStr ? 'from options.md.js' : 'from arg', ', onLoad =',onLoad,')');
    $game_options.value = optionStr;
    $option_bools.innerHTML = '';

    let loadMessage = [];

    optionStr.trim().split('\n').forEach(s => {
      const line = s.trim()[0] === '-' ? s.trim().slice(1) : s.trim();
      const [keyy, ...valueParts] = line.split(':');
      const key = keyy.trim();
      const value = valueParts.join(':').trim();

      if (key === 'options_started_from_source') {
        if (value === '0') {
          loadMessage.push('Options: default');
        } else {
          loadMessage.push('Options from localStorage: ' + value + ' bytes');
        }
      }
      else if (key === 'initial_map_from_source') {
        if (value === '0') {
          loadMessage.push('Progress: not found');
        } else {
          loadMessage.push('Progress from localStorage: ' + value + ' bytes');
        }
      }
      else if (value === 'true' || value === 'false') {
        const e = $option_bools.appendChild(document.createElement('label'));
        e.className = 'option-label';

        const s = e.appendChild(document.createElement('span'));
        s.innerHTML = '<span style="color: #ccc;">options.</span>' + key;

        const i = e.appendChild(document.createElement('input'));
        i.type = 'checkbox';
        i.checked = value === 'true';
        i.onclick = () => {
          console.log('[js] Toggling option', [key], 'to', [!!i.checked]);
          $game_options.value = $game_options.value.replace(new RegExp(`- ${key}: (?:true|false)`), `- ${key}: ${Boolean(i.checked)}`);
          queuedAction = 'apply_options';
          console.log('[js] Stored new options into localStorage');
          window.localStorage.setItem('factini.options', $game_options.value);
        };
      }
    });

    if (loadMessage.length) $warnings.innerHTML = loadMessage.join('<br/>');
  }
  function getExamples() { return GAME_EXAMPLES; }
  function getAction() { let x = queuedAction; queuedAction = ''; return x; }
  function receiveConfigNode(name, pairs) {
    //console.log('[js] receiveConfigNode:', name, '->', pairs);

    const nodeKinds = new Set;
    const nodes = new Map;
    pairs.forEach(([key, value], i) => {
      switch (key) {
        case "kinds": {
          value.forEach(name => nodeKinds.add(name));
          break;
        }

        case "nodes": {
          console.log('[js] raw nodes:', value);
          value.forEach(([raw_name, pairs], j) => {
            const node = pairs.reduce((node, [prop, value]) => { node[prop] = value; return node; }, {});
            node.parents = [];
            node.children = [];
            if (node.sprite_config) {
              node.sprite_config = node.sprite_config.map(pairs => {
                return pairs.reduce((node, [prop, value]) => { node[prop] = value; return node; }, {});
              });
            }
            nodes.set(raw_name, node);
          });
          break;
        }
      }
    });

    nodes.forEach(node => {
      if (node.kind === 'Quest') {
        node.unlocks_after_by_name.forEach(parentRawName => {
          const parent = nodes.get(parentRawName);
          node.parents.push(parent.raw_name);
          parent.children.push(node.raw_name);
        });
      }
    });

    console.log('[js] nodeKinds -->', nodeKinds);
    console.log('[js] nodes -->', nodes);

    //nodes.forEach(node => {
    //  if (node.kind === 'Quest') {
    //    console.log('[js] Quest', node.raw_name, '->', node);
    //  }
    //});

    //nodes.forEach(node => {
    //  if (node.kind === 'Belt') {
    //    console.log('[js] Belt', node.raw_name, '->', node);
    //  }
    //});

    function updateKinds() {
      const titles = [];
      $config_node_titles.length = 0;
      nodeKinds.forEach((name) => {
        const option = document.createElement('option');
        option.innerText = name;
        option.value = name;
        titles.push(option);
      });
      titles.sort((a, b) => a.value < b.value ? -1 : a.value > b.value ? 1 : 0);
      titles.forEach(option => $config_node_titles.appendChild(option));
      updateNodes();
    }
    $config_node_titles.onchange = $config_node_titles.onupdate = updateNodes;

    function updateNodes() {
      const current = $config_node_titles.children[$config_node_titles.selectedIndex].value;
      const cnodes = [];
      $config_node_list.length = 0;
      nodes.forEach((node, name) => {
        if (node.kind === current) {
          const option = document.createElement('option');
          option.innerText = name;
          option.value = name;
          cnodes.push(option);
        }
      });
      cnodes.sort((a, b) => a.value < b.value ? -1 : a.value > b.value ? 1 : 0);
      cnodes.forEach(option => $config_node_list.appendChild(option));

      showNode();
    }
    $config_node_list.onchange = $config_node_list.onupdate = showNode;

    function showSpritePropField(prop, value) {
      document.getElementById('$config_node_' + prop).innerText = value;
      document.getElementById('$p_config_node_' + prop).style.display = 'block';
    }
    function hideSpritePropField(prop) {
      document.getElementById('$p_config_node_' + prop).style.display = 'none';
    }
    function showNode() {
      const rawName = $config_node_list.children[$config_node_list.selectedIndex].value;
      const node = nodes.get(rawName);

      $config_node_index.innerText = node.index;
      $config_node_kind.innerText = node.kind;
      $config_node_name.innerText = node.name;
      $config_node_raw_name.innerText = node.raw_name;

      $sprite_preview.innerHTML = '(no sprite)';
      function showSprite() {
        console.log('[js] sprite:', node);

        const sprite = node.sprite_config[0] || node;

        hideSpritePropField('icon', node.icon);
        showSpritePropField('file', sprite.file);
        showSpritePropField('file_canvas_cache_index', sprite.file_canvas_cache_index);
        showSpritePropField('x', sprite.x);
        showSpritePropField('y', sprite.y);
        showSpritePropField('w', sprite.w);
        showSpritePropField('h', sprite.h);

        const tile = createSprite(0);
        $sprite_preview.innerHTML = '';
        $sprite_preview.appendChild(tile);
      }

      switch (node.kind) {
        case 'Part':
          hideSpritePropField('unlocks_after_by_name');
          hideSpritePropField('unlocks_after_by_index');
          hideSpritePropField('unlocks_todo_by_index');
          hideSpritePropField('starting_part_by_name');
          hideSpritePropField('starting_part_by_index');
          hideSpritePropField('production_target_by_name');
          hideSpritePropField('production_target_by_index');
          showSpritePropField('pattern_by_index', node.pattern_by_index.join(', '));
          showSpritePropField('pattern_by_name', node.pattern_by_name.join(', '));
          showSpritePropField('pattern_by_icon', node.pattern_by_icon.join(', '));
          showSpritePropField('pattern_unique_kinds', node.pattern_unique_kinds.join(', '));

          showSprite();
          break;
        case 'Quest':
          showSpritePropField('unlocks_after_by_name', node.unlocks_after_by_name);
          showSpritePropField('unlocks_after_by_index', node.unlocks_after_by_index);
          showSpritePropField('unlocks_todo_by_index', node.unlocks_todo_by_index);
          showSpritePropField('starting_part_by_name', node.starting_part_by_name);
          showSpritePropField('starting_part_by_index', node.starting_part_by_index);
          showSpritePropField('production_target_by_name', node.production_target_by_name);
          showSpritePropField('production_target_by_index', node.production_target_by_index);
          showSpritePropField('pattern_by_index', node.pattern_by_index);
          showSpritePropField('pattern_by_name', node.pattern_by_name.join(', '));
          showSpritePropField('pattern_by_icon', node.pattern_by_icon.join(', '));
          showSpritePropField('pattern_unique_kinds', node.pattern_unique_kinds.join(', '));
          hideSpritePropField('icon');
          hideSpritePropField('file');
          hideSpritePropField('file_canvas_cache_index');
          hideSpritePropField('x');
          hideSpritePropField('y');
          hideSpritePropField('w');
          hideSpritePropField('h');
          break;
        case 'Supply':
          hideSpritePropField('unlocks_after_by_name', node.unlocks_after_by_name);
          hideSpritePropField('unlocks_after_by_index', node.unlocks_after_by_index);
          hideSpritePropField('unlocks_todo_by_index', node.unlocks_todo_by_index);
          hideSpritePropField('starting_part_by_name', node.starting_part_by_name);
          hideSpritePropField('starting_part_by_index', node.starting_part_by_index);
          hideSpritePropField('production_target_by_name', node.production_target_by_name);
          hideSpritePropField('production_target_by_index', node.production_target_by_index);
          hideSpritePropField('pattern_by_index', node.pattern_by_index);
          hideSpritePropField('pattern_by_name', node.pattern_by_name);
          hideSpritePropField('pattern_by_icon', node.pattern_by_icon);
          hideSpritePropField('pattern_unique_kinds', node.pattern_unique_kinds);
          showSprite();
          break;
        case 'Demand':
          hideSpritePropField('unlocks_after_by_name', node.unlocks_after_by_name);
          hideSpritePropField('unlocks_after_by_index', node.unlocks_after_by_index);
          hideSpritePropField('unlocks_todo_by_index', node.unlocks_todo_by_index);
          hideSpritePropField('starting_part_by_name', node.starting_part_by_name);
          hideSpritePropField('starting_part_by_index', node.starting_part_by_index);
          hideSpritePropField('production_target_by_name', node.production_target_by_name);
          hideSpritePropField('production_target_by_index', node.production_target_by_index);
          hideSpritePropField('pattern_by_index', node.pattern_by_index);
          hideSpritePropField('pattern_by_name', node.pattern_by_name);
          hideSpritePropField('pattern_by_icon', node.pattern_by_icon);
          hideSpritePropField('pattern_unique_kinds', node.pattern_unique_kinds);
          showSprite();
          break;
        case 'Dock':
          hideSpritePropField('unlocks_after_by_name', node.unlocks_after_by_name);
          hideSpritePropField('unlocks_after_by_index', node.unlocks_after_by_index);
          hideSpritePropField('unlocks_todo_by_index', node.unlocks_todo_by_index);
          hideSpritePropField('starting_part_by_name', node.starting_part_by_name);
          hideSpritePropField('starting_part_by_index', node.starting_part_by_index);
          hideSpritePropField('production_target_by_name', node.production_target_by_name);
          hideSpritePropField('production_target_by_index', node.production_target_by_index);
          hideSpritePropField('pattern_by_index', node.pattern_by_index);
          hideSpritePropField('pattern_by_name', node.pattern_by_name);
          hideSpritePropField('pattern_by_icon', node.pattern_by_icon);
          hideSpritePropField('pattern_unique_kinds', node.pattern_unique_kinds);
          showSprite();
          break;
        case 'Machine':
          hideSpritePropField('unlocks_after_by_name', node.unlocks_after_by_name);
          hideSpritePropField('unlocks_after_by_index', node.unlocks_after_by_index);
          hideSpritePropField('unlocks_todo_by_index', node.unlocks_todo_by_index);
          hideSpritePropField('starting_part_by_name', node.starting_part_by_name);
          hideSpritePropField('starting_part_by_index', node.starting_part_by_index);
          hideSpritePropField('production_target_by_name', node.production_target_by_name);
          hideSpritePropField('production_target_by_index', node.production_target_by_index);
          hideSpritePropField('pattern_by_index', node.pattern_by_index);
          hideSpritePropField('pattern_by_name', node.pattern_by_name);
          hideSpritePropField('pattern_by_icon', node.pattern_by_icon);
          hideSpritePropField('pattern_unique_kinds', node.pattern_unique_kinds);
          showSprite();
          break;
        case 'Belt':
          hideSpritePropField('unlocks_after_by_name', node.unlocks_after_by_name);
          hideSpritePropField('unlocks_after_by_index', node.unlocks_after_by_index);
          hideSpritePropField('unlocks_todo_by_index', node.unlocks_todo_by_index);
          hideSpritePropField('starting_part_by_name', node.starting_part_by_name);
          hideSpritePropField('starting_part_by_index', node.starting_part_by_index);
          hideSpritePropField('production_target_by_name', node.production_target_by_name);
          hideSpritePropField('production_target_by_index', node.production_target_by_index);
          hideSpritePropField('pattern_by_index', node.pattern_by_index);
          hideSpritePropField('pattern_by_name', node.pattern_by_name);
          hideSpritePropField('pattern_by_icon', node.pattern_by_icon);
          hideSpritePropField('pattern_unique_kinds', node.pattern_unique_kinds);
          showSprite();
          break;
      }

      $config_node_current_state.innerText = node.current_state;
    }
    function createSprite(frameIndex) {
      const rawName = $config_node_list.children[$config_node_list.selectedIndex].value;
      const node = nodes.get(rawName);
      const sprite = node.sprite_config[frameIndex];

      const finalWidth = 64;
      const finalHeight = 64;
      const scalex = finalWidth / sprite.w;
      const scaley = finalHeight / sprite.h;

      // The outer gives a viewport on the inner, scaled, div. Cutting away the overflow.
      const outer = document.createElement('div');
      // The inner has the image as background with a zoom factor to scale the sprite
      const inner = outer.appendChild(document.createElement('img'));
      inner.src = sprite.file;
      outer.style = `position: relative; width: ${finalWidth}px; height: ${finalHeight}px; overflow: hidden; float: right; border: 1px solid black;`;
      inner.style = `position: absolute; left: -${Math.round(scalex * sprite.x)}px; top: -${Math.round(scaley * sprite.y)}px; transform: scale(${scalex}, ${scaley}); transform-origin: top left;`;

      return outer;
    }

    function createNewDraggableTile() {
      const tile = createSprite(0);
      const wrapper = document.createElementById('div');
      wrapper.appendChild(tile);
      $sprite_preview.parentNode.insertBefore(wrapper, $sprite_preview);
      return tile;
    }

    updateKinds();

    {
      // flowchart.fun syntax:
      //  [Quest_Start] Start; 10x_IngotWhite
      //    (Quest_Shield)
      //    (Quest_BlueBottle)
      //    (Quest_WhiteBook)
      //  [Quest_Shield] Shield; 10x_ShieldWood
      //    (Quest_BlueShield)
      //  [Quest_BlueBottle] BlueBottle; 10x_PotionBlue
      //    (Quest_BlueShield)
      //    (Quest_BlueBook)
      //  [Quest_BlueShield] BlueShield; 10x_ShieldBlue
      //    (Quest_BookShield)
      //  [Quest_WhiteBook] WhiteBook; 10x_BookWhite
      //    (Quest_BlueBook)
      //  [Quest_BlueBook] BlueBook; 10x_BookBlue
      //    (Quest_BookShield)

      const arr = [];
      nodes.forEach(node => {
        if (node.kind === 'Quest') {
          arr.push(`[${node.raw_name}] ${node.name}; ${node.production_target_by_name.map(([count, qname]) => `${count}x_${qname.split('_')[1]}`).join(' ')}`);
          node.production_target_by_name.forEach(([count, name]) => {
            node.children.forEach(childName => {
              arr.push(`\t(${childName})`);
            })
          });
        }
      });
      console.log('[js] uncomment next line to print the flowchart.fun code');
      //console.log('[js] flowchart.fun code:\n' + arr.join('\n'));
    }

    updateMermaid(nodes);

    nodes.forEach(node => {
      if (node.kind !== 'Part') return;
      // index: node_index,
      // kind:
      // name: name.to_string(),
      // raw_name: rest.to_string(),
      // unlocks_after_by_name: vec!(),
      // unlocks_after_by_index: vec!(),
      // unlocks_todo_by_index: vec!(),
      // starting_part_by_name: vec!(),
      // starting_part_by_index: vec!(),
      // production_target_by_name: vec!(),
      // production_target_by_index: vec!(),
      // pattern_by_index: vec!(),
      // pattern_by_name: vec!(),
      // pattern_by_icon: vec!(),
      // pattern_unique_kinds: vec!(),
      // icon,
      // file: "".to_string(),
      // file_canvas_cache_index: 0,
      // x: 0.0,
      // y: 0.0,
      // w: 0.0,
      // h: 0.0,
      // current_state: ConfigNodeState::Waiting,

      const finalWidth = 64;
      const finalHeight = 64;
      const scalex = finalWidth / node.sprite_config[0]?.w;
      const scaley = finalHeight / node.sprite_config[0]?.h;

      // The outer gives a viewport on the inner, scaled, div. Cutting away the overflow.
      const outer = $all_parts.appendChild(document.createElement('div'));
      outer.title = `${node.raw_name}`;
      // The inner has the image as background with a zoom factor to scale the sprite
      const inner = outer.appendChild(document.createElement('img'));
      inner.src = node.sprite_config[0]?.file;
      outer.style = `position: relative; width: ${finalWidth}px; height: ${finalHeight}px; overflow: hidden; float: right; border: 1px solid black;`;
      inner.style = `position: absolute; left: -${Math.round(scalex * node.sprite_config[0]?.x)}px; top: -${Math.round(scaley * node.sprite_config[0]?.y)}px; transform: scale(${scalex}, ${scaley}); transform-origin: top left;`;
    });
  }
  function updateMermaid(nodes) {
    // mermaid:
    //   graph TD;
    //    A-->B;
    //    A-->C;
    //    B-->D;
    //    C-->D;
    //    B[Line breaks <br />work in<br />decision nodes]

    const arr = [
      'graph LR'
    ];
    nodes.forEach(node => {
      if (node.kind === 'Quest') {
        node.children.forEach(childName => {
          arr.push(`  ${node.raw_name}-->${childName};`);
        });

        arr.push(`
            ${node.raw_name}[<span id=&quot;$q_${node.raw_name}&quot;>
              <b>${node.raw_name}</b><br/>
              <small><b>Enables:</b></small><br/>
              ${node.starting_part_by_name.map((qname) => `<span style=&quot;cursor:help&quot; title=&quot;Components:${nodes.get(qname).pattern_by_name.join(',')||'resource'}&quot;>${qname.split('_')[1]}</span>`).join(' <br/> ')}<br/>
              <small><b>Targets:</b></small><br/>
              ${node.production_target_by_name.map(([count, qname]) => `${count}x ${qname.split('_')[1]}`).join(' <br/> ')}
            </span>]
          `.replace(/\n/g, ''));
      }
    });
    console.log('[js] Note: the mermaid.live code is just text, uncomment to print');
    //console.log('[js] mermaid.live code (may need to remove special descs):\n' + arr.join('\n'));
    $mermaid.removeAttribute('data-processed'); // :facepalm: not obvious but ok. ht https://stackoverflow.com/questions/73056709/mermaid-in-react-turns-into-plaintext-when-re-rendered
    $mermaid.innerHTML = arr.join('\n');
    mermaid.init();
  }
  function onQuestUpdate(pairs) {
    //console.log('(JS) onQuestUpdate():', pairs);
    pairs.forEach(([name, value]) => {
      const e = document.getElementById(`$q_${name}`);
      if (e) {
        e.style.backgroundColor = value === 'Active' ? 'yellow' : value === 'Waiting' ? '' : 'lightgreen';
      } else {
        console.log('Warning: onQuestUpdate():', name, '->', value, 'could not find mermaid node');
      }
    });
  }

  function getLastPaste() {
    // When you press ctrl+v the event handler will store the value you pasted and prepare an action for the game to be read it
    // Then when the game reads the action it will call this function to retrieve the stored paste value
    return queuedPaste || '';
  }
  function getCurrentPaste() {
    // Called from Rust when clicking the "paste" button. Due to unstable api limitations I could not get this to work inside Rust
    // so instead I'm just doing it from JS and sending the result back in once there is one. Bit a pingpong but whatever.

    // This doesn't work in firefox rn, but it seems firefox only supports clipboard reading through extensions or the paste event.
    // This will popup a permission dialog once
    try {
      navigator.clipboard.readText().then(
        s => {
          queuedPaste = s;
          queuedAction = 'paste';
        },
        err => {
          console.error('(js) getCurrentPaste: failed to navigator.clipboard.readText():', err);
          queuedPaste = ''; // This will show the ctrl+v message
          queuedAction = 'paste';
        }
      );
    } catch {
      console.log('(js) Browser does not support navigator.clipboard :shrug:');
      queuedPaste = ''; // This will show the ctrl+v message
      queuedAction = 'paste';
    }
  }
  function copyToClipboard(str) {
    try {
      navigator
        .clipboard
        .writeText(str)
        .then((ok) => console.log('(js) copyToClipboard ok:', ok), (err) => console.log('(js) copyToClipboard err:', err));
      return true;
    } catch (e) {
      console.log('(js) copyToClipboard threw error:', e);
      return false;
    }
  }

</script>
<script type="module">
  Error.stackTraceLimit = Infinity;
  console.log('(html) start');
  import('../pkg/factini.js').then(x => {
    console.log('(html) loaded, starting Factini now');
    x.default();
  }, (e) => console.error(e));
  console.log('(html) after import');

  window.addEventListener('paste', e => {
    // Ironically, this works fine even in firefox. :shrug:
    e.preventDefault();
    console.log('(js) received paste event with', e.clipboardData?.items?.length, 'items');
    e.clipboardData.items[0].getAsString(s => {
      queuedPaste = s;
      queuedAction = 'paste';
    });
  });

  window.addEventListener('copy', e => {
    // Ironically, this works fine even in firefox. :shrug:
    e.preventDefault();
    console.log('(js) received copy event');
    queuedAction = 'copy';
  });
</script>
<!-- for flow graphs of the quests -->

<div id="$main_game" style="float: left; clear: both; user-select: none;"></div>

<div style="float: right; clear: right; margin-top: 5px;">
  Clear local:
  <button onclick="window.localStorage.removeItem('factini.options'); $warnings.innerHTML = 'options cleared from localStorage<br/>';">options</button>
  <button onclick="window.localStorage.removeItem('factini.lastMap'); $warnings.innerHTML = 'progress cleared from localStorage<br/>';">progress</button>
</div>
<div style="float: right; clear: right; margin-top: 5px;"><hr/>Options:</div>
<div id="$warnings" style="float: right; clear: right; color: red; cursor: pointer;"><br/><br/></div>
<div id="$option_bools"></div>
<style>
  .option-label { float: right; clear: right; cursor: pointer; }
  .option-label:hover { background-color: yellow; }
</style>
<textarea id="$game_options" style="float: right; clear: right; min-width: 50px; min-height: 50px; width: 300px; height: 100px; margin-top: 5px; margin-right: 5px;" autocomplete="off" spellcheck="false"></textarea>
<script>setGameOptions(GAME_OPTIONS);</script>
<button style="float: right; clear: right; margin-top: 5px; margin-right: 5px;" onclick="queuedAction = 'apply_options';">Apply options</button>

<textarea id="$game_map" style="float: right; clear: right; min-width: 50px; min-height: 50px; width: 400px; height: 300px; margin-top: 5px; margin-right: 5px;" autocomplete="off" spellcheck="false" onClick="this.select();"></textarea>
<script>$game_map.value = GAME_MAP.trim();</script>
<button style="float: right; clear: right; margin-top: 5px; margin-right: 5px;" onclick="queuedAction = 'load_map';">Set as map</button>

<div style="clear: both;">
  <div><hr/>Config:</div>
  <div>
    <div>Quest Tree:</div>
    <div style="float: right;">
      <textarea id="$game_config" style="min-width: 50px; min-height: 50px; width: 400px; height: 100px; margin-top: 5px; margin-right: 5px;" autocomplete="off" spellcheck="false"></textarea>
      <script>$game_config.value = (GAME_CONFIG_PRELUDE + GAME_CONFIG_ASSETS + GAME_CONFIG_BELTS + GAME_CONFIG_MACHINES + DEV_QUEST_PARTS + DEV_QUEST_QUESTS + GAME_CONFIG_SUPPLYDEMANDOCK + CONFIG_BUCKET_QUEST + MAZE_STORY).trim();</script>
      <div id="$sprite_preview"></div>
      <div style="margin-bottom: 15px;"><button style="margin-top: 5px; margin-right: 5px;" onclick="queuedAction = 'load_config';">Set as config</button></div>
      <div id="$config_editor">
        <div id="$config_node_kinds"></div>
        <div><select id="$config_node_titles" style="margin-bottom: 5px;"></select></div>
        <div><select id="$config_node_list" style="margin-bottom: 5px;"></select></div>
        <div id="$config_node_editor" style="text-align: right;">
          <style>
              .key { font-weight: bold; font-size: 12px; margin: 0 5px 0 5px; }
              .value { padding-left: 10px; }
          </style>
          <div id="$p_config_node_index" style="white-space: pre;"><span class="key">index:</span><span id="$config_node_index" class="value"></span></div>
          <div id="$p_config_node_kind" style="white-space: pre;"><span class="key">kind:</span><span id="$config_node_kind" class="value"></span></div>
          <div id="$p_config_node_name" style="white-space: pre;"><span class="key">name:</span><span id="$config_node_name" class="value"></span></div>
          <div id="$p_config_node_raw_name" style="white-space: pre;"><span class="key">raw_name:</span><span id="$config_node_raw_name" class="value"></span></div>
          <div id="$p_config_node_unlocks_after_by_name"><span class="key">unlocks_after_by_name:</span><span id="$config_node_unlocks_after_by_name" class="value"></span></div>
          <div id="$p_config_node_unlocks_after_by_index" style="white-space: pre;"><span class="key">unlocks_after_by_index:</span><span id="$config_node_unlocks_after_by_index" class="value"></span></div>
          <div id="$p_config_node_unlocks_todo_by_index" style="white-space: pre;"><span class="key">unlocks_todo_by_index:</span><span id="$config_node_unlocks_todo_by_index" class="value"></span></div>
          <div id="$p_config_node_starting_part_by_name"><span class="key">starting_part_by_name:</span><span id="$config_node_starting_part_by_name" class="value"></span></div>
          <div id="$p_config_node_starting_part_by_index" style="white-space: pre;"><span class="key">starting_part_by_index:</span><span id="$config_node_starting_part_by_index" class="value"></span></div>
          <div id="$p_config_node_production_target_by_name"><span class="key">production_target_by_name:</span><span id="$config_node_production_target_by_name" class="value"></span></div>
          <div id="$p_config_node_production_target_by_index" style="white-space: pre;"><span class="key">production_target_by_index:</span><span id="$config_node_production_target_by_index" class="value"></span></div>
          <div id="$p_config_node_pattern_by_index" style="white-space: pre;"><span class="key">pattern_by_index:</span><span id="$config_node_pattern_by_index" class="value"></span></div>
          <div id="$p_config_node_pattern_by_name"><span class="key">pattern_by_name:</span><span id="$config_node_pattern_by_name" class="value"></span></div>
          <div id="$p_config_node_pattern_by_icon" style="white-space: pre;"><span class="key">pattern_by_icon:</span><span id="$config_node_pattern_by_icon" class="value"></span></div>
          <div id="$p_config_node_pattern_unique_kinds" style="white-space: pre;"><span class="key">pattern_unique_kinds:</span><span id="$config_node_pattern_unique_kinds" class="value"></span></div>
          <div id="$p_config_node_icon" style="white-space: pre;"><span class="key">icon:</span><span id="$config_node_icon" class="value"></span></div>
          <div id="$p_config_node_file"><span class="key">file:</span><span id="$config_node_file" class="value"></span></div>
          <div id="$p_config_node_file_canvas_cache_index" style="white-space: pre;"><span class="key">file_canvas_cache_index:</span><span id="$config_node_file_canvas_cache_index" class="value"></span></div>
          <div id="$p_config_node_x" style="white-space: pre;"><span class="key">x:</span><span id="$config_node_x" class="value"></span></div>
          <div id="$p_config_node_y" style="white-space: pre;"><span class="key">y:</span><span id="$config_node_y" class="value"></span></div>
          <div id="$p_config_node_w" style="white-space: pre;"><span class="key">w:</span><span id="$config_node_w" class="value"></span></div>
          <div id="$p_config_node_h" style="white-space: pre;"><span class="key">h:</span><span id="$config_node_h" class="value"></span></div>
          <div id="$p_config_node_current_state" style="white-space: pre;"><span class="key">current_state:</span><span id="$config_node_current_state" class="value"></span></div>
        </div>
      </div>
    </div>
    <script src="./lib/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad: false});</script>
    <div class="mermaid" id="$mermaid" style="white-space:pre;"></div>
  </div>
</div>

<div style="clear: both;" id="$all_parts"></div>

</body>
</html>
